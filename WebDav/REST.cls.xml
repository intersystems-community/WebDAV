<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="WebDav.REST">
<Super>%CSP.REST</Super>
<TimeCreated>64370,45626.334444</TimeCreated>

<Parameter name="HTTP200OK">
<Type>%String</Type>
<Default>200 OK</Default>
</Parameter>

<Parameter name="HTTP207MULTISTATUS">
<Type>%String</Type>
<Default>207 Multi Status</Default>
</Parameter>

<Parameter name="HTTP404NOTFOUND">
<Type>%String</Type>
<Default>404 Not Found</Default>
</Parameter>

<Parameter name="HandleCorsRequest">
<Default>1</Default>
</Parameter>

<Parameter name="CONTENTTYPE">
<Default>text/xml</Default>
</Parameter>

<Parameter name="FOLDER">
<Default>^WebDav.Settings("Folder")</Default>
</Parameter>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>

   <!-- IMPLEMENTED -->
   <Route Url="(.*)" Method="PROPFIND" Call="PROPFIND"/>
   <Route Url="(.*)" Method="GET" Call="GET"/>
   <Route Url="(.*)" Method="PUT" Call="PUT"/>
   <Route Url="(.*)" Method="DELETE" Call="DELETE"/>
   <Route Url="(.*)" Method="MOVE" Call="MOVE"/>
   <Route Url="(.*)" Method="MKCOL" Call="MKCOL"/>
   
   <!-- 200 OK -->
   <Route Url="(.*)" Method="HEAD" Call="HEAD"/>
   <Route Url="(.*)" Method="PROPPATCH" Call="PROPPATCH"/>
   <Route Url="(.*)" Method="LOCK" Call="LOCK"/>
   <Route Url="(.*)" Method="UNLOCK" Call="UNLOCK"/>
   
   
   <!-- UNIMPLEMENTED -->
   <Route Url="(.*)" Method="POST" Call="POST"/>
   <Route Url="(.*)" Method="TRACE" Call="TRACE"/>
   <Route Url="(.*)" Method="COPY" Call="COPY"/>
   <Route Url="(.*)" Method="ORDERPATCH" Call="ORDERPATCH"/>
 </Routes>
]]></Data>
</XData>

<Method name="OnPreDispatch">
<Description>
This method Gets called prior to dispatch of the request. Put any common code here
that you want to be executed for EVERY request. If pContinue is set to 0, the
request will NOT be dispatched according to the UrlMap. If this case it's the
responsibility of the user to return a response.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pUrl:%String,pMethod:%String,&pContinue:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pContinue = $$$YES
	/// maybe require only for OPTIONS
	/// https://msdn.microsoft.com/en-us/library/aa142827(v=exchg.65).aspx
	/// https://www.webdavsystem.com/server/documentation/ms_office_read_only/
    do %response.SetHeader("DAV","1, 2")
    
    /// Helps MS Office on Windows, does not affect Mac office
    /// https://msdn.microsoft.com/en-us/library/cc250217.aspx
    do %response.SetHeader("MS-Author-Via","DAV")
    quit $$$OK
]]></Implementation>
</Method>

<Method name="PROPFIND">
<Description>
w ##class(WebDav.REST).PROPFIND()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set path = ..href2path(href)
	//s ^dbg.PROPFIND($i(^dbg.PROPFIND)) = $lb(href, depth, isCollection, $zt($p($h,",",2)),@..#FOLDER)
	
	if ##class(%File).Exists(path) {	
		set depth = 1
		if $isobject($g(%request))  {
			set %response.Status = ..#HTTP207MULTISTATUS
			
			set depth = %request.GetCgiEnv("HTTP_DEPTH", 0)				
		}
		set isCollection = ..isCollection(href)
		
			
		set multi = ##class(WebDav.XML.multistatus).%New()
		do multi.response.Insert(..createResponse(href))
		
		if isCollection,depth {		
			#dim rs As %ResultSet = ##class(%File).FileSetFunc(path)

			while (rs.%Next()) {
				set path = rs.Name		
				set name = rs.ItemName
				set size =rs.Size
				
				do multi.response.Insert(..createResponse(href _ "/" _ name, size))
			}
		}
		
		set sc = ..writeXML(multi)

	} else {
		set %response.Status =  ..#HTTP404NOTFOUND
		set sc =$$$OK
	}
	quit sc
]]></Implementation>
</Method>

<Method name="writeXML">
<ClassMethod>1</ClassMethod>
<FormalSpec>obj:%XML.Adaptor</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set w=##class(%XML.Writer).%New()
	set w.DefaultNamespace = "DAV:"
	do w.AddNamespace("DAV:","D")
 	set w.ElementQualified = $$$NO
 	set w.Indent=1

 	quit w.RootObject(obj)
]]></Implementation>
</Method>

<Method name="createResponse">
<ClassMethod>1</ClassMethod>
<FormalSpec>href,size:%Integer=0</FormalSpec>
<ReturnType>WebDav.XML.response</ReturnType>
<Implementation><![CDATA[
	set isCollection = ..isCollection(href)
	
	set response = ##class(WebDav.XML.response).%New()
	do response.href.Insert(..getBase() _ href)
	
	set propstat = ##class(WebDav.XML.propstat).%New()
	set propstat.status = "HTTP/1.1 " _ ..#HTTP200OK
	
	set prop = ##class(WebDav.XML.prop).%New()
	set prop.getlastmodified = "Mon, 27 Mar 2017 11:54:36 GMT" // $p($zdt($h,5), " ") _ ", " _ $zdt($h,2) _ " GMT"
	set prop.displayname = $case(isCollection, 1: $p(href, "/", *), :##class(%File).GetFilename(href))
	set prop.iscollection = isCollection
	set prop.creationdate = prop.getlastmodified
	set prop.lockdiscovery = ##class(WebDav.XML.lockdiscovery).%New()
	set prop.supportedlock = ##class(WebDav.XML.supportedlock).%New()
	set prop.getcontentlength = size
	
	if isCollection {
		set prop.resourcetype.collection = ##class(WebDav.XML.empty).%New()
	}
	
	set propstat.prop = prop
	do response.propstat.Insert(propstat)
	
	return response
]]></Implementation>
</Method>

<Method name="getBase">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set https = $s(%request.IsDefinedCgiEnv("HTTPS"):%request.GetCgiEnv("HTTPS", $$$NO), 1:$$$NO)
	set protocol = "http" _ $case(https, $$$YES: "s", :"") _"://"
	set host = %request.GetCgiEnv("HTTP_HOST")
	set app = %request.Application
	set:app="/" app = "" 
	
	quit protocol _ host _ app
]]></Implementation>
</Method>

<Method name="href2path">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if $$$isWINDOWS {
		set path = @..#FOLDER _ $tr(href,"/","\")
	} else {
		set path = @..#FOLDER _ href
	}
	return path
]]></Implementation>
</Method>

<Method name="isCollection">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	return href '[ "."
]]></Implementation>
</Method>

<Method name="serve">
<ClassMethod>1</ClassMethod>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim sc As %Status = $$$OK
    #dim %response As %CSP.Response
	kill %request.Data
	set %request.Data("STREAMOID",1)= ##class(%CSP.StreamServer).Encrypt(##class(%CSP.StreamServer).GetOidForFile(name))
	if ##class(%CSP.StreamServer).OnPreHTTP() {
		set %response.Headers("Content-Disposition")="attachment; filename*=UTF-8''" _ ##class(%CSP.Page).EscapeURL("1.txt", "UTF8")
		set sc = ##class(%CSP.StreamServer).OnPage()
	}

	quit sc
]]></Implementation>
</Method>

<Method name="GET">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	s ^dbg2($i(^dbg2)) = $lb(href, @..#FOLDER _ href, $zt($p($h,",",2)))
	q ..serve(..href2path(href))
]]></Implementation>
</Method>

<Method name="PROPPATCH">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[	q $$$OK
]]></Implementation>
</Method>

<Method name="UNLOCK">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[	q $$$OK
]]></Implementation>
</Method>

<Method name="MKCOL">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	set path = ..href2path(href)
	do ##class(%File).CreateDirectoryChain(path)
	q $$$OK
]]></Implementation>
</Method>

<Method name="MOVE">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set path = ..href2path(href)
	
	set dest = %request.GetCgiEnv("HTTP_DESTINATION")
	set destHref = $p(dest, ..getBase(), 2, *)
	set destPath =..href2path(destHref)
	
	set result = ##class(%File).Rename(path, destPath)
	set ^dbg.MOVE($i(^dbg.MOVE)) = $lb(href, path, dest, destPath, result)
	q $$$OK
]]></Implementation>
</Method>

<Method name="DELETE">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	set path = ..href2path(href)
	set ^dbg.DELETE($i(^dbg.DELETE)) = $lb(href, path, $zt($p($h,",",2)))
	do ##class(%File).Delete(path)
	q $$$OK
]]></Implementation>
</Method>

<Method name="HEAD">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set path = ..href2path(href)
	do ##class(%CSP.StreamServer).FileClassify($p(path, ".", *), .type , .bin, .charset)
	
	set %response.ContentType = type  //"application/vnd.openxmlformats-officedocument.wordprocessingml.document"
	set %response.ContentLength = ##class(%File).GetFileSize(href)
	do %response.SetHeader("Accept-Ranges","bytes")
	do %response.SetHeader("Last-Modified","Mon, 27 Mar 2017 11:03:16 GMT")
	do %response.SetHeader("ETag","""a68375bce9a6d21:0""")
	
	s ^dbg4($i(^dbg4)) = $lb(href, $zt($p($h,",",2)))
	q $$$OK
]]></Implementation>
</Method>

<Method name="PUT">
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim sc As %Status = $$$OK
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	if $isobject(%request.Content) {
		set ^dbg3($i(^dbg3)) = $lb(href, @..#FOLDER _ href, $zt($p($h,",",2)), %request.Content.Read($$$MaxLocalLength))
		
		set file = ##class(%Stream.FileBinary).%New()
		do file.LinkToFile(..href2path(href))
		set sc = file.CopyFromAndSave(%request.Content)
	} else {
		set file = ##class(%File).%New(..href2path(href))
		do file.Open("WSN")
		set sc = file.%Save()
	}
	quit sc
]]></Implementation>
</Method>

<Method name="LOCK">
<Description>
w ##class(WebDav.REST).LOCK()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href="/2/1.txt"</FormalSpec>
<Implementation><![CDATA[
	//w ..getClassXData(,"LOCK2") q 1
	
	set prop = ##class(WebDav.XML.prop).%New()
	set prop.lockdiscovery = ##class(WebDav.XML.lockdiscovery).%New()
	
	set active = ##class(WebDav.XML.activelock).%New()
	set active.locktype = ##class(WebDav.XML.locktype).%New()
	set active.lockscope = ##class(WebDav.XML.lockscope).%New()
	set active.lockscope.exclusive = ##class(WebDav.XML.empty).%New()
	set active.depth = 0
	set active.timeout = "Second-3600"
	
	set active.owner = ##class(WebDav.XML.owner).%New()
	set active.owner.content = "ed-pc\eduard"
	
	set active.lockroot = ##class(WebDav.XML.lockroot).%New()
	do active.lockroot.href.Insert(..getBase() _ href)
	
	set active.locktoken = ##class(WebDav.XML.locktoken).%New()
	do active.locktoken.href.Insert("opaquelocktoken:" _ $System.Util.CreateGUID())
	
	//set exclusive = ##class(WebDav.XML.lockentry).%New()
	//set exclusive.locktype.write = ##class(WebDav.XML.write).%New()

	//set shared = ##class(WebDav.XML.lockentry).%New()
	//set shared.lockscope.shared = ##class(WebDav.XML.empty).%New()
	//set shared.locktype.write = ##class(WebDav.XML.write).%New()	

	
	do prop.lockdiscovery.activelock.Insert(active)
	
	quit ..writeXML(prop)
]]></Implementation>
</Method>
</Class>
</Export>
