<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="25">
<Class name="WebDav.REST">
<Description>
WebDAV Server Currently serves physical directory structure.</Description>
<Super>%CSP.REST</Super>
<TimeCreated>64370,45626.334444</TimeCreated>

<Parameter name="HTTP200OK">
<Type>%String</Type>
<Default>200 OK</Default>
</Parameter>

<Parameter name="HTTP207MULTISTATUS">
<Type>%String</Type>
<Default>207 Multi Status</Default>
</Parameter>

<Parameter name="HTTP404NOTFOUND">
<Type>%String</Type>
<Default>404 Not Found</Default>
</Parameter>

<Parameter name="HandleCorsRequest">
<Default>1</Default>
</Parameter>

<Parameter name="CONTENTTYPE">
<Default>text/xml</Default>
</Parameter>

<Parameter name="FOLDER">
<Description>
Root folder for a WebDAV server. Should be set without trailing slash</Description>
<Default>^WebDav.Settings("Folder")</Default>
</Parameter>

<XData name="UrlMap">
<Data><![CDATA[
<Routes>

   <!-- IMPLEMENTED -->
   <Route Url="(.*)" Method="PROPFIND" Call="PROPFIND"/>
   <Route Url="(.*)" Method="GET" Call="GET"/>
   <Route Url="(.*)" Method="PUT" Call="PUT"/>
   <Route Url="(.*)" Method="DELETE" Call="DELETE"/>
   <Route Url="(.*)" Method="MOVE" Call="MOVE"/>
   <Route Url="(.*)" Method="MKCOL" Call="MKCOL"/>
   
   <!-- 200 OK -->
   <Route Url="(.*)" Method="HEAD" Call="HEAD"/>
   <Route Url="(.*)" Method="PROPPATCH" Call="PROPPATCH"/>
   <Route Url="(.*)" Method="LOCK" Call="LOCK"/>
   <Route Url="(.*)" Method="UNLOCK" Call="UNLOCK"/>
   
   
   <!-- UNIMPLEMENTED -->
   <Route Url="(.*)" Method="POST" Call="POST"/>
   <Route Url="(.*)" Method="TRACE" Call="TRACE"/>
   <Route Url="(.*)" Method="COPY" Call="COPY"/>
   <Route Url="(.*)" Method="ORDERPATCH" Call="ORDERPATCH"/>
 </Routes>
]]></Data>
</XData>

<Method name="OnPreDispatch">
<Description>
This method Gets called prior to dispatch of the request. Put any common code here
that you want to be executed for EVERY request. If pContinue is set to 0, the
request will NOT be dispatched according to the UrlMap. If this case it's the
responsibility of the user to return a response.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pUrl:%String,pMethod:%String,&pContinue:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pContinue = ..securityCheck(pUrl, pMethod)
	/// maybe require only for OPTIONS
	/// https://msdn.microsoft.com/en-us/library/aa142827(v=exchg.65).aspx
	/// https://www.webdavsystem.com/server/documentation/ms_office_read_only/
    do %response.SetHeader("DAV","1, 2")
    
    /// Helps MS Office on Windows, does not affect Mac office
    /// https://msdn.microsoft.com/en-us/library/cc250217.aspx
    do %response.SetHeader("MS-Author-Via","DAV")
    quit $$$OK
]]></Implementation>
</Method>

<Method name="securityCheck">
<Description>
Chech if client is allowed to make this request</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUrl:%String,pMethod:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	quit $$$YES
]]></Implementation>
</Method>

<Method name="PROPFIND">
<Description>
PROPFIND request is used to retrieve properties, stored as XML, from a web resource.
It is also overloaded to allow one to retrieve the collection structure (a.k.a. directory hierarchy) of a remote system.
w ##class(WebDav.REST).PROPFIND()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set path = ..href2path(href)
	do ##class(WebDav.Log).add("PROPFIND", href, path, ##class(%File).Exists(path))
	if ##class(%File).Exists(path) {
		set depth = 1
		if $isobject($g(%request))  {
			set %response.Status = ..#HTTP207MULTISTATUS
			
			set depth = %request.GetCgiEnv("HTTP_DEPTH", 0)				
		}
		set isCollection = ..isCollection(href)
		
			
		set multi = ##class(WebDav.XML.multistatus).%New()
		do multi.response.Insert(..createResponse(href))
		
		if isCollection,depth {		
			#dim rs As %ResultSet = ##class(%File).FileSetFunc(path)

			while (rs.%Next()) {
				set path = rs.Name		
				set name = rs.ItemName
				set size =rs.Size
				set createdDate = rs.DateCreated
				set modifiedDate = rs.DateModified
				
				do multi.response.Insert(..createResponse(href _ "/" _ name, size, createdDate, modifiedDate))
			}
		}
		
		set sc = ..writeXML(multi)

	} else {
		set %response.Status =  ..#HTTP404NOTFOUND
		set sc = $$$OK
	}
	quit sc
]]></Implementation>
</Method>

<Method name="writeXML">
<Description>
Output XML in a mode compliant with WebDAV clients
obj - is any xml-enabled object</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>obj:%XML.Adaptor</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set w=##class(%XML.Writer).%New()
	set w.Charset = "UTF-8"
	set w.DefaultNamespace = "DAV:"
	do w.AddNamespace("DAV:","D")
 	set w.ElementQualified = $$$NO
 	set w.Indent=1	

 	quit w.RootObject(obj)
]]></Implementation>
</Method>

<Method name="createResponse">
<Description>
Create PROPFIND response for one file or directory.</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href,size:%Integer=0,createdDate="",modifiedDate=""</FormalSpec>
<ReturnType>WebDav.XML.response</ReturnType>
<Implementation><![CDATA[
	set isCollection = ..isCollection(href)
	
	set response = ##class(WebDav.XML.response).%New()
	do response.href.Insert(..getBase() _ $zcvt($zcvt(href, "O", "UTF8"), "O", "URL"))
	
	set propstat = ##class(WebDav.XML.propstat).%New()
	set propstat.status = "HTTP/1.1 " _ ..#HTTP200OK
	
	set prop = ##class(WebDav.XML.prop).%New()
	set prop.getlastmodified = ..ts2httpDate(modifiedDate)
	set prop.creationdate = ##class(%TimeStamp).LogicalToXSD(createdDate)
	
	set displayName = $case(isCollection, 1: $p(href, "/", *), :##class(%File).GetFilename(href))
	set prop.displayname = $zcvt($zcvt(displayName,"O","UTF8"),"O","URL")
	set prop.iscollection = isCollection
	set prop.lockdiscovery = ##class(WebDav.XML.lockdiscovery).%New()
	set prop.supportedlock = ##class(WebDav.XML.supportedlock).%New()
	set prop.getcontentlength = size
		
	if isCollection {
		set prop.resourcetype.collection = ##class(WebDav.XML.empty).%New()
	}
	
	set propstat.prop = prop
	do response.propstat.Insert(propstat)
	
	return response
]]></Implementation>
</Method>

<Method name="ts2httpDate">
<Description>
Converts timestamp into HTTP date as defined in section 3.3.1 of [RFC2068]
https://tools.ietf.org/html/rfc2068#section-3.3.1
RFC 822, updated by RFC 1123 (preferred):  wkday "," SP date SP time SP "GMT"
Example: Sun, 06 Nov 1994 08:49:37 GMT
w ##class(WebDav.REST).ts2httpDate("2017-03-31 15:17:59")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ts:%TimeStamp=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	quit:ts="" ""
	set h = $zdth(ts, 3)
	set h = $system.Util.LocalWithZTIMEZONEtoUTC(h)
	set wkday = $zd(h, 11,,,,,,,, 1)
	set date = $zd(h, 2,,,,,,,, 1)
	set time = $zt($p(h,",",2),1)
	quit wkday _ ", " _ date _ " " _ time _ " GMT"
]]></Implementation>
</Method>

<Method name="getBase">
<Description>
Get WebDAV server root URL</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	if $isobject($g(%request)) {
		set https = $s(%request.IsDefinedCgiEnv("HTTPS"):%request.GetCgiEnv("HTTPS", $$$NO), 1:$$$NO)
		set protocol = "http" _ $case(https, $$$YES: "s", :"") _"://"
		set host = %request.GetCgiEnv("HTTP_HOST")
		set app = %request.Application
		set:app="/" app = "" 
	} else {
		set protocol = "http"
		set host = "localhost:57772"
		set app = ""
	}	
	quit protocol _ host //_ app
]]></Implementation>
</Method>

<Method name="href2path">
<Description>
Convert request href into physical path</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if $$$isWINDOWS {
		set path = @..#FOLDER _ $tr(href,"/","\")
	} else {
		set path = @..#FOLDER _ href
	}
	return path
]]></Implementation>
</Method>

<Method name="isCollection">
<Description>
Check if requested object is a directory or a file</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[	return ##class(%File).DirectoryExists(..href2path(href))
]]></Implementation>
</Method>

<Method name="serve">
<Description>
Return physical file  contents</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#dim sc As %Status = $$$OK
    #dim %response As %CSP.Response
	kill %request.Data
	set %request.Data("STREAMOID",1)= ##class(%CSP.StreamServer).Encrypt(##class(%CSP.StreamServer).GetOidForFile(name))
	if ##class(%CSP.StreamServer).OnPreHTTP() {
		set %response.Headers("Content-Disposition")="attachment; filename*=UTF-8''" _ ##class(%CSP.Page).EscapeURL(##class(%File).GetFilename(name), "UTF8")
		set sc = ##class(%CSP.StreamServer).OnPage()
	}

	quit sc
]]></Implementation>
</Method>

<Method name="GET">
<Description>
Retrieve file contents</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	set path = ..href2path(href)
	set sc = ..serve(path)
	do ##class(WebDav.Log).add("GET", href, path, sc)
	quit sc
]]></Implementation>
</Method>

<Method name="PROPPATCH">
<Description>
PROPPATCH is used to update object properties</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="UNLOCK">
<Description>
Reverse to LOCK, UNLOCK removes lock from an object </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[	quit $$$OK
]]></Implementation>
</Method>

<Method name="MKCOL">
<Description>
MaKeCOLlection creates a directory</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	set path = ..href2path(href)
	do ##class(%File).CreateDirectoryChain(path)
	quit $$$OK
]]></Implementation>
</Method>

<Method name="MOVE">
<Description>
Moves object</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set path = ..href2path(href)
	
	set dest = %request.GetCgiEnv("HTTP_DESTINATION")
	set destHref = $p(dest, ..getBase(), 2, *)
	set destPath =..href2path(destHref)
	
	/// If a resource exists at the destination and the Overwrite header is "T", then prior to performing the move, 
	/// the server MUST perform a DELETE with "Depth: infinity" on the destination resource. 
	/// If the Overwrite header is set to "F", then the operation will fail.
	/// No one sends that header
	if ##class(%File).Exists(destPath),..securityCheck(destHref, "DELETE") {
		do ..DELETE(destHref)
	}
	
	set result = ##class(%File).Rename(path, destPath)
	do ##class(WebDav.Log).add("MOVE", href, path, result, destPath)
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DELETE">
<Description>
Deletes object</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	set path = ..href2path(href)
	
	if ..isCollection(href) {
		set sc = ##class(%File).RemoveDirectoryTree(path)
	} else {
		set sc = ##class(%File).Delete(path)
	}
	
	do ##class(WebDav.Log).add("DELETE", href, path, sc)
	
	quit $$$OK
]]></Implementation>
</Method>

<Method name="HEAD">
<Description>
Called befor GET to receive information about a file</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	
	set path = ..href2path(href)

	set %response.ContentType = ..getFileType(path)
	set %response.ContentLength = ##class(%File).GetFileSize(href)
	//do %response.SetHeader("Accept-Ranges","bytes")
	//do %response.SetHeader("Last-Modified","Mon, 27 Mar 2017 11:03:16 GMT")
	//do %response.SetHeader("ETag","""a68375bce9a6d21:0""")

	quit $$$OK
]]></Implementation>
</Method>

<Method name="getFileType">
<Description>
Determine file mime type</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>path</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set ext = "/" _ $zcvt($p(path, ".", *),"U") _ "/"
	do ##class(%CSP.StreamServer).FileClassify(ext, .type , .bin, .charset)
	if ext = "/RTF/" {
		set type = "application/rtf"
	}
	
	return type
]]></Implementation>
</Method>

<Method name="PUT">
<Description>
Update file contents. Always completely rewrites the file </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href</FormalSpec>
<Implementation><![CDATA[
	#dim sc As %Status = $$$OK
	#dim %response As %CSP.Response
	#dim %request As %CSP.Request
	set path = ..href2path(href)
	if $isobject(%request.Content) {		
		set file = ##class(%Stream.FileBinary).%New()
		do file.LinkToFile(path)
		set sc = file.CopyFromAndSave(%request.Content)
	} else {
		set file = ##class(%File).%New(path)
		do file.Open("WSN")
		set sc = file.%Save()
	}
	do ##class(WebDav.Log).add("PUT", href, path, sc)
	quit sc
]]></Implementation>
</Method>

<Method name="LOCK">
<Description>
Acquire a lock on a file
w ##class(WebDav.REST).LOCK()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>href="/2/1.txt"</FormalSpec>
<Implementation><![CDATA[
	set token = "opaquelocktoken:" _ $System.Util.CreateGUID()
	do %response.SetHeader("Lock-Token", token)
	
	set prop = ##class(WebDav.XML.prop).%New()
	set prop.lockdiscovery = ##class(WebDav.XML.lockdiscovery).%New()
	
	set active = ##class(WebDav.XML.activelock).%New()
	set active.locktype = ##class(WebDav.XML.locktype).%New()
	set active.lockscope = ##class(WebDav.XML.lockscope).%New()
	set active.lockscope.exclusive = ##class(WebDav.XML.empty).%New()
	set active.depth = 0
	set active.timeout = "Second-3600"
	
	set active.owner = ##class(WebDav.XML.owner).%New()
	set active.owner.content = "ed-pc\eduard"
	
	set active.lockroot = ##class(WebDav.XML.lockroot).%New()
	do active.lockroot.href.Insert(..getBase() _ href)
	
	set active.locktoken = ##class(WebDav.XML.locktoken).%New()
	do active.locktoken.href.Insert(token)
	
	//set exclusive = ##class(WebDav.XML.lockentry).%New()
	//set exclusive.locktype.write = ##class(WebDav.XML.write).%New()

	//set shared = ##class(WebDav.XML.lockentry).%New()
	//set shared.lockscope.shared = ##class(WebDav.XML.empty).%New()
	//set shared.locktype.write = ##class(WebDav.XML.write).%New()	

	
	do prop.lockdiscovery.activelock.Insert(active)
	
	quit ..writeXML(prop)
]]></Implementation>
</Method>
</Class>
</Export>
